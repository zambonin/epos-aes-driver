#include "utility/aes/aes.h"
#include "utility/aes/sys_ctrl.h"
#include "utility/ostream.h"

using namespace EPOS;

OStream cout;

/*****************************************************************************/
/*   This example shows how to run AES ECB with polling on EPOSMote III.     */
/*   It uses no peripherals, no I/O signals, and no interrupt handlers.      */
/*****************************************************************************/

typedef struct {
  unsigned char ui8AESKey[16], ui8AESKeyLocation, ui8AESBuf[16],
      ui8AESExpectedOutput[16];
} tAESExample;

bool AESMemCmp(const unsigned char *pui8Src1, const unsigned char *pui8Src2,
               unsigned int ui32Len) {
  const unsigned char *pui8Src1Temp = pui8Src1;
  const unsigned char *pui8Src2Temp = pui8Src2;

  while (ui32Len--) {
    if (*pui8Src1Temp++ != *pui8Src2Temp++) {
      return false;
    }
  }
  return true;
}

unsigned char AesEcbExample(unsigned char *pui8Key,
                            unsigned char ui8KeyLocation,
                            unsigned char *pui8Buf,
                            unsigned char *pui8ExpectedOutput) {
  AESLoadKey((unsigned char *)pui8Key, ui8KeyLocation);
  AESECBStart(pui8Buf, pui8Buf, ui8KeyLocation, true, false);

  do {
    ASM_NOP;
  } while (!(AESECBCheckResult()));

  AESECBGetResult();

  if (AESMemCmp(pui8Buf, pui8ExpectedOutput, 16) == false) {
    return AES_ECB_TEST_ERROR;
  }

  return (AES_SUCCESS);
}

int main(void) {
  unsigned char ui8Status;

  // Set the clocking to run directly from the external crystal/oscillator.
  // (no ext 32k osc, no internal osc)
  // SysCtrlClockSet(false, false, SYS_CTRL_SYSDIV_32MHZ);

  // Set IO clock to the same as system clock
  // SysCtrlIOClockSet(SYS_CTRL_SYSDIV_32MHZ);

  // Enable AES peripheral
  SysCtrlPeripheralReset(SYS_CTRL_PERIPH_AES);
  SysCtrlPeripheralEnable(SYS_CTRL_PERIPH_AES);

  tAESExample sAESexample[] = {
      {
          {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00},
          0,
          {0x6c, 0x5f, 0x51, 0x74, 0x53, 0x53, 0x77, 0x5a, 0x5a, 0x5f, 0x57,
           0x58, 0x55, 0x53, 0x06, 0x0f},
          {0x83, 0x78, 0x10, 0x60, 0x0e, 0x13, 0x93, 0x9b, 0x27, 0xe0, 0xd7,
           0xe4, 0x58, 0xf0, 0xa9, 0xd1},
      },
      {
          {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00},
          1,
          {0x6c, 0x5f, 0x51, 0x74, 0x53, 0x53, 0x77, 0x5a, 0x5a, 0x5f, 0x57,
           0x58, 0x55, 0x53, 0x06, 0x0f},
          {0x83, 0x78, 0x10, 0x60, 0x0e, 0x13, 0x93, 0x9b, 0x27, 0xe0, 0xd7,
           0xe4, 0x58, 0xf0, 0xa9, 0xd1},
      },
      {
          {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00},
          2,
          {0x6c, 0x5f, 0x51, 0x74, 0x53, 0x53, 0x77, 0x5a, 0x5a, 0x5f, 0x57,
           0x58, 0x55, 0x53, 0x06, 0x0f},
          {0x83, 0x78, 0x10, 0x60, 0x0e, 0x13, 0x93, 0x9b, 0x27, 0xe0, 0xd7,
           0xe4, 0x58, 0xf0, 0xa9, 0xd1},
      },
      {
          {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00},
          3,
          {0x6c, 0x5f, 0x51, 0x74, 0x53, 0x53, 0x77, 0x5a, 0x5a, 0x5f, 0x57,
           0x58, 0x55, 0x53, 0x06, 0x0f},
          {0x83, 0x78, 0x10, 0x60, 0x0e, 0x13, 0x93, 0x9b, 0x27, 0xe0, 0xd7,
           0xe4, 0x58, 0xf0, 0xa9, 0xd1},
      },
      {
          {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00},
          4,
          {0x6c, 0x5f, 0x51, 0x74, 0x53, 0x53, 0x77, 0x5a, 0x5a, 0x5f, 0x57,
           0x58, 0x55, 0x53, 0x06, 0x0f},
          {0x83, 0x78, 0x10, 0x60, 0x0e, 0x13, 0x93, 0x9b, 0x27, 0xe0, 0xd7,
           0xe4, 0x58, 0xf0, 0xa9, 0xd1},
      },
      {
          {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00},
          5,
          {0x6c, 0x5f, 0x51, 0x74, 0x53, 0x53, 0x77, 0x5a, 0x5a, 0x5f, 0x57,
           0x58, 0x55, 0x53, 0x06, 0x0f},
          {0x83, 0x78, 0x10, 0x60, 0x0e, 0x13, 0x93, 0x9b, 0x27, 0xe0, 0xd7,
           0xe4, 0x58, 0xf0, 0xa9, 0xd1},
      },
      {
          {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00},
          6,
          {0x6c, 0x5f, 0x51, 0x74, 0x53, 0x53, 0x77, 0x5a, 0x5a, 0x5f, 0x57,
           0x58, 0x55, 0x53, 0x06, 0x0f},
          {0x83, 0x78, 0x10, 0x60, 0x0e, 0x13, 0x93, 0x9b, 0x27, 0xe0, 0xd7,
           0xe4, 0x58, 0xf0, 0xa9, 0xd1},
      },
      {
          {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00},
          7,
          {0x6c, 0x5f, 0x51, 0x74, 0x53, 0x53, 0x77, 0x5a, 0x5a, 0x5f, 0x57,
           0x58, 0x55, 0x53, 0x06, 0x0f},
          {0x83, 0x78, 0x10, 0x60, 0x0e, 0x13, 0x93, 0x9b, 0x27, 0xe0, 0xd7,
           0xe4, 0x58, 0xf0, 0xa9, 0xd1},
      },
  };

  for (unsigned char i = 0; i < sizeof(sAESexample) / sizeof(sAESexample[0]);
       i++) {
    ui8Status = AesEcbExample(
        sAESexample[i].ui8AESKey, sAESexample[i].ui8AESKeyLocation,
        sAESexample[i].ui8AESBuf, sAESexample[i].ui8AESExpectedOutput);
    if (ui8Status != AES_SUCCESS) {
      cout << "fail" << endl;
    } else {
      cout << "success " << i << endl;
    }
  }

  return 0;
}
